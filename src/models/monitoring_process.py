"""
MonitoringProcess model for managing article monitoring tasks.

This model represents monitoring processes that users create to
track myMoment articles and automatically generate AI comments.
"""

from datetime import datetime, timedelta
from typing import List
import uuid

from sqlalchemy import Column, String, Boolean, DateTime, Integer, Text, UUID, ForeignKey
from sqlalchemy.orm import relationship

from src.models.base import Base, BaseModel


class MonitoringProcess(BaseModel):
    """MonitoringProcess manages article monitoring and AI commenting tasks."""

    __tablename__ = "monitoring_processes"

    # Primary fields
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4, nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
    llm_provider_id = Column(
        UUID(as_uuid=True),
        ForeignKey("llm_provider_configurations.id", ondelete="SET NULL"),
        nullable=True
    )

    # Process configuration
    name = Column(String(200), nullable=False)
    description = Column(Text, nullable=True)
    generate_only = Column(Boolean, nullable=False, default=True)

    # Monitoring criteria
    category_filter = Column(Integer, nullable=True)  # myMoment category ID
    search_filter = Column(String(200), nullable=True)  # Search terms
    tab_filter = Column(String(50), nullable=True)  # myMoment tab / class id
    sort_option = Column(String(50), nullable=True)  # Sort criteria

    # Process control
    max_duration_minutes = Column(Integer, nullable=False, default=60)  # FR-008: Duration limits
    status = Column(String(50), nullable=False, default="created")  # created, running, stopped, completed, failed

    # Stage-specific Celery task IDs for parallel pipeline (v3.0+)
    celery_discovery_task_id = Column(String(255), nullable=True, index=True)
    celery_preparation_task_id = Column(String(255), nullable=True, index=True)
    celery_generation_task_id = Column(String(255), nullable=True, index=True)
    celery_posting_task_id = Column(String(255), nullable=True, index=True)

    # Process execution tracking
    started_at = Column(DateTime(timezone=True), nullable=True)
    stopped_at = Column(DateTime(timezone=True), nullable=True)
    last_activity_at = Column(DateTime(timezone=True), nullable=True)

    # Stage-specific progress tracking (v3.0+)
    articles_discovered = Column(Integer, default=0, nullable=False)
    articles_prepared = Column(Integer, default=0, nullable=False)
    comments_generated = Column(Integer, default=0, nullable=False)
    comments_posted = Column(Integer, default=0, nullable=False)

    # Stage-specific error tracking (v3.0+)
    errors_encountered_in_discovery = Column(Integer, default=0, nullable=False)
    errors_encountered_in_preparation = Column(Integer, default=0, nullable=False)
    errors_encountered_in_generation = Column(Integer, default=0, nullable=False)
    errors_encountered_in_posting = Column(Integer, default=0, nullable=False)

    # Status tracking
    is_active = Column(Boolean, nullable=False, default=True)

    # Timestamps
    # Note: nullable=True due to SQLite limitations on ALTER TABLE
    created_at = Column(DateTime(timezone=True), nullable=True, default=datetime.utcnow)
    updated_at = Column(DateTime(timezone=True), nullable=True, default=datetime.utcnow, onupdate=datetime.utcnow)

    # Relationships
    user = relationship("User", back_populates="monitoring_processes")
    llm_provider = relationship("LLMProviderConfiguration", back_populates="monitoring_processes")

    # Many-to-many relationships via junction tables
    monitoring_process_logins = relationship(
        "MonitoringProcessLogin",
        back_populates="monitoring_process",
        cascade="all, delete-orphan"
    )
    monitoring_process_prompts = relationship(
        "MonitoringProcessPrompt",
        back_populates="monitoring_process",
        cascade="all, delete-orphan"
    )

    # AI comments generated by this process
    ai_comments = relationship("AIComment", back_populates="monitoring_process")

    def __repr__(self) -> str:
        return f"<MonitoringProcess(id={self.id}, name='{self.name}', status='{self.status}', user_id={self.user_id})>"

    @property
    def duration_exceeded(self) -> bool:
        """Check if the process has exceeded its maximum duration."""
        if not self.started_at or self.status != "running":
            return False

        duration = datetime.utcnow() - self.started_at
        max_duration = timedelta(minutes=self.max_duration_minutes)
        return duration > max_duration

    @property
    def is_running(self) -> bool:
        """Check if the process is currently running."""
        return self.status == "running"

    @property
    def can_start(self) -> bool:
        """Check if the process can be started."""
        return self.status in ["created", "stopped"] and self.is_active

    @property
    def error_message(self) -> str:
        """Get error message if process failed."""
        if self.status == "failed":
            total_errors = (
                self.errors_encountered_in_discovery +
                self.errors_encountered_in_preparation +
                self.errors_encountered_in_generation +
                self.errors_encountered_in_posting
            )
            return f"Process failed after {total_errors} errors"
        return None

    @property
    def expires_at(self) -> datetime:
        """Calculate when the process will automatically expire."""
        if not self.started_at:
            return None
        return self.started_at + timedelta(minutes=self.max_duration_minutes)

    @property
    def prompt_template_ids(self) -> List[uuid.UUID]:
        """Get list of prompt template IDs associated with this process."""
        return [mpp.prompt_template_id for mpp in self.monitoring_process_prompts if mpp.is_active]

    @property
    def mymoment_login_ids(self) -> List[uuid.UUID]:
        """Get list of myMoment login IDs associated with this process."""
        return [mpl.mymoment_login_id for mpl in self.monitoring_process_logins if mpl.is_active]

    @property
    def target_filters(self) -> dict:
        """Get target filters as a dictionary for API responses."""
        filters = {}
        if self.category_filter is not None:
            filters['category'] = self.category_filter
        if self.search_filter:
            filters['search'] = self.search_filter
        if self.tab_filter:
            filters['tab'] = self.tab_filter
        if self.sort_option:
            filters['sort'] = self.sort_option
        return filters if filters else None

    def get_associated_logins(self) -> List["MyMomentLogin"]:
        """Get all myMomentLogin credentials associated with this process."""
        return [mpl.mymoment_login for mpl in self.monitoring_process_logins if mpl.is_active]

    def get_associated_prompts(self) -> List["PromptTemplate"]:
        """Get all prompt templates associated with this process."""
        return [mpp.prompt_template for mpp in self.monitoring_process_prompts if mpp.is_active]
